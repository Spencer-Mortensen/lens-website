<p>Fatal errors are seemingly impossible to catch.
A try-catch block can handle an <a href="http://php.net/manual/en/class.exception.php">Exception</a> or an <a href="http://php.net/manual/en/class.error.php">Error</a>, but a raw PHP notice, warning, or error will slip right through!</p>

<code>try {
	define(Pi, 3);
} catch (Exception $exception) {
	echo 'Not executed!';
} catch (Error $error) {
	echo 'Not executed!';
}</code>

<p>The raw PHP errors aren’t thrown objects, so they can’t be caught in a try-catch block.
But, they <i>can</i> be turned into exceptions using the <a href="http://php.net/manual/en/function.set-error-handler.php">set_error_handler</a>:</p>

<code>&lt;?php

$onError = function ($level, $message, $file, $line) {
    $message = trim($message);
    $code = null;

    throw new ErrorException($message, $code, $level, $file, $line);
};

set_error_handler($onError);

try {
    define(Pi, 3);
} catch (Exception $exception) {
	echo 'Exception: ', $exception->getMessage(), "\n";
} catch (Error $error) {
	echo 'Error: ', $error->getMessage(), "\n";
}

restore_error_handler();</code>

<p>This lets us catch raw PHP errors!</p>

<p>Unfortunately, this only works on the <i>mildest</i> of errors.
The more severe errors cannot be caught this way (E_ERROR, E_PARSE, E_CORE_ERROR, E_CORE_WARNING, E_COMPILE_ERROR, E_COMPILE_WARNING, and many E_STRICT errors).</p>

<p>The trouble is that PHP <i>shuts down</i> when it encounters a fatal error, so our try-catch block won’t even run.
But there is one thing that <i>will</i> run just before PHP shuts down: <i>a shutdown function</i>.</p>

<code>&lt;?php

$onShutdown = function () {
	$error = error_get_last();

	if ($error === null) {
		return;
	}

	$message = trim($error['message']);
	$code = null;
	$level = $error['type'];
	$file = $error['file'];
	$line = $error['line'];

	$exception = new ErrorException($message, $code, $level, $file, $line);

	echo "Exception: ", $exception->getMessage(), "\n";
};

register_shutdown_function($onShutdown);
error_reporting(0);

// E_COMPILE_ERROR:
require '';

echo 'Not executed!';</code>

<p>This does indeed allow us to catch fatal errors!</p>

<p>But the shutdown function will <i>always</i> run—even during a normal shutdown.
We need a bullet-proof way to distinguish between a normal and an abnormal shutdown.
Whatever we choose, it must be more reliable than simply checking the last error value, since that won’t work in every case.</p>